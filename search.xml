<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode判断一个括号字符串是否是合法的</title>
      <link href="/2018/11/18/LeetCode-ValidParentheses/"/>
      <url>/2018/11/18/LeetCode-ValidParentheses/</url>
      
        <content type="html"><![CDATA[<p><strong>描述：Valid Parentheses</strong> <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">题目地址</a><br></p><p><strong>Example:</strong></p><blockquote><p><strong>输入:</strong> “{()}[]” -&gt; true<br><strong>输入:</strong> “({)}[]” -&gt; false<br><strong>输入:</strong> “[]” -&gt; true<br><strong>输入:</strong> “” -&gt; true</p></blockquote><p><strong>思路分析: 使用栈结构来处理</strong></p><p><strong>栈介绍:</strong> 先进后出(FILO), 例如子弹夹, 将元素放入栈中叫<code>压栈</code> 将元素从栈中弹出叫<code>出栈</code> <br></p><p>以字符串 <code>{()}</code> 为例: </p><blockquote><p>1, 第一个元素 <code>{</code> 入栈<br>2, 第二个元素 <code>(</code> 判断和<code>栈顶</code>的元素不匹配, 也将其压入栈中<br>3, 第三个元素 <code>)</code> 和<code>栈顶</code>元素匹配, 所以将<code>栈顶</code>元素弹出, 然后栈中只剩下 <code>{</code><br>4, 第四个元素 <code>}</code> 和现在的<code>栈顶</code>元素匹配, 所以也将<code>栈顶</code>元素弹出, 现在为<code>空栈</code><br>5, 返回结果: <code>括号字符串是合法的</code></p></blockquote><p><img src="example.png" alt="example"></p><p><strong>代码实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>alan<span class="token punctuation">.</span>leetcode<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 判断一个字符串括号是否是合法的 * @author Alan Wang * @date 2018/11/18 14:43 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ValidParentheses</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token string">"[({)]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Character<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 字符串转换为字符数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> aChar <span class="token operator">:</span> chars<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 查看栈顶的是否匹配</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>aChar<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>aChar<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>aChar<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>aChar<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> chars<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="https://github.com/AlanWangBit/Java-Advanced/blob/master/java-algorithm/src/main/java/com/alan/leetcode/ValidParentheses.java" target="_blank" rel="noopener">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程实战-第二章：线程的安全性</title>
      <link href="/2018/11/13/JavaConcurrencyInPractice2/"/>
      <url>/2018/11/13/JavaConcurrencyInPractice2/</url>
      
        <content type="html"><![CDATA[<!-- MarkdownTOC autolink="true" autoanchor="false" --><ul><li><a href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">2.1 什么是线程安全</a></li><li><a href="#22-%E5%8E%9F%E5%AD%90%E6%80%A7">2.2 原子性</a><ul><li><a href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">竞态条件</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E7%9A%84%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">示例：延迟初始化中的竞态条件</a></li><li><a href="#%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C">复合操作</a></li></ul></li><li><a href="#23-%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6">2.3 加锁机制</a><ul><li><a href="#%E5%86%85%E7%BD%AE%E9%94%81">内置锁</a></li><li><a href="#%E9%87%8D%E5%85%A5">重入</a></li></ul></li><li><a href="#24-%E7%94%A8%E9%94%81%E6%9D%A5%E4%BF%9D%E6%8A%A4%E7%8A%B6%E6%80%81">2.4 用锁来保护状态</a></li><li><a href="#25-%E6%B4%BB%E8%B7%83%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD">2.5 活跃性与性能</a></li></ul><!-- /MarkdownTOC --><h1 id="2-1-什么是线程安全"><a href="#2-1-什么是线程安全" class="headerlink" title="2.1 什么是线程安全"></a>2.1 什么是线程安全</h1><p><code>定义：</code> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，则称该类是<code>线程安全的</code>。</p><p><code>无状态对象一定是线程安全的</code></p><p><code>无状态：</code> 既不包含任何全局域，也不包含任何对其他类中域的引用。</p><p><strong>一个无状态的类</strong> 一个基于 <code>Servlet</code> 的因式分解服务</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatelessFactorizer</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span>ServletRequest req<span class="token punctuation">,</span> ServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger i <span class="token operator">=</span> <span class="token function">extractFromRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> factors <span class="token operator">=</span> <span class="token function">factor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> factors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h1><p>在上节中的因式分解服务中，添加一个计数器，用来统计处理的请求数量，代码如下：</p><p><strong>这是一个线程不安全的类</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsafeCountingFactorizer</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计数器</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span>ServletRequest req<span class="token punctuation">,</span> ServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger i <span class="token operator">=</span> <span class="token function">extractFromRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> factors <span class="token operator">=</span> <span class="token function">factor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>count<span class="token punctuation">;</span>        <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> factors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代码中是线程不安全的，首先 <code>++count</code> 是一个 <code>非原子性</code> 的操作，而是包含了三个独立的操作：<code>读取count</code> <code>修改count</code> <code>写入count</code><br>如果线程A和线程B同时都读取到count的值为0，两个线程在各自的私有内存中将只修改为1，然后又分别将1写入到主内存，那么显然丢失了一次统计</p><p>这种因为多线程的执行顺序引起的不正确的情况成为 <code>竞态条件</code></p><h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p>常见的竞态条件就是: <code>先检查后执行</code> 的操作, 即通过一个可能已经失效的结果来决定下一步的动作。</p><h2 id="示例：延迟初始化中的竞态条件"><a href="#示例：延迟初始化中的竞态条件" class="headerlink" title="示例：延迟初始化中的竞态条件"></a>示例：延迟初始化中的竞态条件</h2><p><strong>这是一个非线程安全的类</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyInitRace</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ExpensiveObject instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    ExpensiveObject <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpensiveObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码是无法保证 <code>正确性</code> 的，假设线程A执行if判断是得到instance==null为true，但在线程A执行new语句之前，线程B也执行if判断得到了instance==null为true，<br>那么线程A和线程B将都会执行new语句，则将会创建出两个对象。</p><h2 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h2><blockquote><p>复合操作：包含了一组必须以原子方式执行的操作以确保线程的安全性，此处我们先使用现有的线程安全类来解决线程安全问题</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountingFactorizer</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicLong count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Service</span><span class="token punctuation">(</span>ServletRequest req<span class="token punctuation">,</span> ServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger i <span class="token operator">=</span> <span class="token function">extractFromRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> factors <span class="token operator">=</span> <span class="token function">factor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> factors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码使用 <code>AtomicLong</code> 来代替 <code>long</code> 类型，<code>AtomicLong</code> 是 <code>java.util.concurrent.atomic</code> 包中的原子变量类，用于实现数值和对象引用上的原子状态转换。<br>使用 <code>AtomicLong</code> 来修改count，能够确保所有线程对count的状态访问都是原子的，因为上述类中只有一个count状态，所以上述的类是线程安全的。</p><h1 id="2-3-加锁机制"><a href="#2-3-加锁机制" class="headerlink" title="2.3 加锁机制"></a>2.3 加锁机制</h1><p>上一节的 <code>CountingFactorizer</code> 类中只有一个状态，所以使用 <code>AtomicLong</code> 修改状态就可以保证整个类的线程安全，但是，如果类中增加一种或几种状态，是否可以通过线程安全类来修改所有的状态就能保证类的线程安全呢？？？</p><p>假如，在我们因式分解的例子中，需要添加一种缓存机制，如果连续的两个请求时对同一个数进行因式分解，则直接使用上一次计算的结果，所以需要保存上一次因式分解的数值，和计算结果</p><p><strong>线程不安全的代码演示</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsafeCachingFactorizer</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 上一次因式分解的数值</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicReference<span class="token operator">&lt;</span>BigInteger<span class="token operator">></span> lastNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 上一次因式分解的结果</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicReference<span class="token operator">&lt;</span>BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> lastFactors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Service</span><span class="token punctuation">(</span>ServletRequest req<span class="token punctuation">,</span> ServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取要进行因式分解的数值</span>        BigInteger i <span class="token operator">=</span> <span class="token function">extractFromRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 上一次已经计算过，直接使用上一次的结果</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lastNumber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> lastFactors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 计算因式分解</span>            BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> factors <span class="token operator">=</span> <span class="token function">factor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录本次的计算结果，以备后续使用</span>            lastNumber<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastFactors<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>factors<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> factors<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代码中使用了原子引用类来修改类中的两个状态，但是UnsafeCachingFactorizer类中存在竞态条件，无法保证线程的安全性；<br>假设我们有线程A和线程B，如果两个线程要因式分解同一个数值，那么我们来分析一些上面代码中的缓存有没有生效。</p><blockquote><p>首先 <code>set()</code> 操作时原子性的，但是无法保证lastNumber和lastFactors同时更新，假如线程A成功的set了lastNumber的值，但在线程A设置lastFactors的值之前，线程B执行了get操作，那么显然线程B将得到一个错误的数值。</p></blockquote><p>显然，线程安全的不变性条件被破坏，此处的不变性条件应该是：lastFactors中缓存的数据应该是lastNumber的因式分解的结果，所以在修改了lastNumber而没有修改lastFactors的值，而其他线程有机会执行，则破坏了不变性条件，所以无法确保线程的安全。</p><h2 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h2><p>Java 通过内置锁机制支持原子性：同步代码块机制<br>同步代码块包括两部分：<code>一个作为锁的对象引用</code>，<code>一个作为有该锁保护的代码块</code>？？？？？？？？？？？？？？（需要后续继续解读）</p><blockquote><p>普通同步方法，锁是当前实例对象 ？？？？？？？？？？？？？？（需要后续继续解读）<br>静态同步方法，锁是当前类的Class对象 ？？？？？？？？？？？？？？（需要后续继续解读）<br>同步代码块，锁是括号中配置的对象 ？？？？？？？？？？？？？？（需要后续继续解读）</p></blockquote><p>由于一次只能有一个线程进入同步代码块，所以内置锁保护的代码块是原子方式执行的。</p><p><strong>使用synchronized保证安全，但该例子性能很差</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedFactorizer</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 上一次因式分解的数值</span>    <span class="token keyword">private</span> BigInteger lastNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 上一次因式分解的结果</span>    <span class="token keyword">private</span> BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> lastFactors<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">Service</span><span class="token punctuation">(</span>ServletRequest req<span class="token punctuation">,</span> ServletResponse resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取要进行因式分解的数值</span>        BigInteger i <span class="token operator">=</span> <span class="token function">extractFromRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 上一次已经计算过，直接使用上一次的结果</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lastNumber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> lastFactors<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 计算因式分解</span>            BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> factors <span class="token operator">=</span> <span class="token function">factor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录本次的计算结果，以备后续使用</span>            lastNumber<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastFactors<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>factors<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> factors<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>每一个锁都会关联一个<code>获取锁计数器</code> 和一个 <code>获取锁的线程</code>，计数器为0表示没有线程获取到锁，当一个线程获取到一个计数器为0的锁时，JVM记录锁的持有者，并且设置计数器值为1，此时其他线程将等待锁的释放，如果同一个线程再次获取锁(<code>重入</code>)，计数器+1，而当线程退出代码块，计数器将会相应递减，当计数器减为0，则释放锁。</p><p>锁的重入：<code>降低多次获取和释放锁的性能损耗</code> <code>避免了某种死锁的发生</code>(如下)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingWidget</span> <span class="token keyword">extends</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": calling doSomething"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>上述代码中，两次调用 <code>doSomething()</code> 方法都需要获取 <code>Widget</code> 上的锁(<code>或者在同一个类中的一个加锁方法中调用另一个加锁的方法也会发生锁的重入</code>)，如果锁不能重入，则无法调用 <code>super.doSomethis()</code> 因为锁已经被同一个线程获取，所以线程将永远无法获取到锁，避免了这种死锁情况的发生</p></blockquote><h1 id="2-4-用锁来保护状态"><a href="#2-4-用锁来保护状态" class="headerlink" title="2.4 用锁来保护状态"></a>2.4 用锁来保护状态</h1><p>对象的内置锁与其状态之间没有内在的关联</p><p>对象的域不一定要通过内置锁来保护</p><blockquote><p>当线程获取到某个对象的锁时，并不能阻止其他线程访问对象，只能阻止其他线程获取锁。</p></blockquote><p>如果在类的每个方法上都加锁，也无法确保复合操作都是 <code>原子性</code> 的，例如 <code>Vector</code> 类;<br>例如下面代码中的 <code>contains()</code> 方法和 <code>add()</code> 方法都是加锁的，当时if代码块中的复合操作并不是原子性的，<br>因为线程A在获取到锁调用用 contains 方法后可能会释放锁，此时如果其他线程获取了锁则结果将不可预知。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VectorTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="2-5-活跃性与性能"><a href="#2-5-活跃性与性能" class="headerlink" title="2.5 活跃性与性能"></a>2.5 活跃性与性能</h1><p>缩小同步代码块的范围，可以既能确保较高的 <code>并发性</code> 又能维护 <code>线程安全性</code>，要确保同步代码块不要太小，而且不要将本应该时原子的操作拆分到多个代码块中，<br>应该尽量将 <code>不影响共享状态</code> 且 <code>执行时间较长</code> 的操作从同步代码块中分离出来。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CachedFactorizer</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 上一次计算的数据     */</span>    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">"this"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> BigInteger lastNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 上一次求出的结果     */</span>    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">"this"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> lastFactors<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 请求次数     */</span>    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">"this"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">long</span> hits<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">"this"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">long</span> cacheHits<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span>ServletRequest servletRequest<span class="token punctuation">,</span> ServletResponse servletResponse<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger i <span class="token operator">=</span> <span class="token function">extractFormRequest</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        BigInteger<span class="token punctuation">[</span><span class="token punctuation">]</span> factors <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 统计请求次数</span>            <span class="token operator">++</span>hits<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果要计算的数据已经计算过了</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lastNumber<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>cacheHits<span class="token punctuation">;</span>                factors <span class="token operator">=</span> lastFactors<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>factors <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            factors <span class="token operator">=</span> <span class="token function">factor</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                lastNumber <span class="token operator">=</span> i<span class="token punctuation">;</span>                lastFactors <span class="token operator">=</span> factors<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">encodeIntoResponse</span><span class="token punctuation">(</span>servletResponse<span class="token punctuation">,</span> factors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>当执行时间教程的计算或者无法快速完成的操作时（如网络IO），一定不要持有锁。</p></blockquote><blockquote><p>通常，当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能会破坏安全性）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode交换链表中相邻的两个元素</title>
      <link href="/2018/11/12/LeetCodeSwapNodesInPairs/"/>
      <url>/2018/11/12/LeetCodeSwapNodesInPairs/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>描述：Swap Nodes in Pairs</strong> <a href="https://leetcode.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">题目地址</a><br></p><p><strong>Example:</strong></p><blockquote><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null<br><strong>输出:</strong> 2-&gt;1-&gt;4-&gt;3-&gt;5-&gt;null</p></blockquote><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><strong>思路分析: 如下图</strong></p><blockquote><p><code>curr</code> 为当前正在遍历的元素, 我们称它为 <code>a元素</code><br><code>next</code> 当前元素的后面一个元素, 我们称他为 <code>b元素</code><br><code>c</code> 元素为当前元素后面的第二个元素<br><code>prev</code> 元素为当前遍历到的元素的前一个元素, 如果当前遍历的为第一个元素，则 <code>prev=null;</code>（前面一部分链表的最后一个节点）</p></blockquote><blockquote><p>(1), curr.next = next.next; // <code>a元素</code> 的 <code>next</code> 指向 <code>c元素</code><br>(2), next.next = curr; // <code>b元素</code> 的 <code>next</code> 指向 <code>a元素</code><br>(3), prev.next = next; // <code>prev</code> 元素指向 <code>b元素</code>(将链表前面一半的元素和后面的元素链接上)<br>(4), prev = curr; //交换之后，a元素是前面元素的最后一个元素，所以更新 <code>prev</code> 指向 <code>a元素</code><br>(5), curr = curr.next; // 下一次遍历的元素为 <code>a元素</code> 的下一个元素</p></blockquote><p><img src="listnode.png" alt="listnode"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>alan<span class="token punctuation">.</span>leetcode<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alan<span class="token punctuation">.</span>leetcode<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>ListNodeUtil<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author Alan Wang * @Date 2018/11/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwapNodesInPairs</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode head <span class="token operator">=</span> ListNodeUtil<span class="token punctuation">.</span><span class="token function">generateListNode</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------开始交换----------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SwapNodesInPairsSolution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SwapNodesInPairsSolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode listNode <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode node <span class="token operator">=</span> listNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 交换链表中相邻的两个元素 */</span><span class="token keyword">class</span> <span class="token class-name">SwapNodesInPairsSolution</span> <span class="token punctuation">{</span>    ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前正在遍历的元素</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前正在遍历的元素的后一个</span>        ListNode next<span class="token punctuation">,</span> prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 假设链表为：prev->a->b->c->null         */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> curr<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取当前元素的下一个元素</span>            next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将a的next指向b的next</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将b的next指向a</span>            next<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将a前面一个元素的next指向b</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                head <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// prev 指向元素a</span>            prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 元素a往后移动一位</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode反转链表</title>
      <link href="/2018/11/11/leetCode-reverseLinkedlist/"/>
      <url>/2018/11/11/leetCode-reverseLinkedlist/</url>
      
        <content type="html"><![CDATA[<!-- MarkdownTOC autolink="true" autoanchor="false" --><!-- /MarkdownTOC --><p><strong>描述：反转一个单向链表</strong> <a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="noopener">题目地址</a><br></p><p><strong>Example:</strong></p><blockquote><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null <br><br><strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null <br></p></blockquote><p><strong>思路分析</strong></p><blockquote><p><code>currNode</code> 当前正在遍历的节点(原链表头节点)<br><code>prevNode</code> 新链表节点头节点(最初新链表为空所以初始值为null)</p></blockquote><blockquote><p><strong>因为每次遍历时, 都会修改当前遍历节点的 <code>next</code> 所以每次修改前应该先记录当前的 <code>next</code> 即原链表修改后的头节点</strong></p></blockquote><pre class=" language-java"><code class="language-java">ListNode nextTemp <span class="token operator">=</span> currNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span></code></pre><blockquote><p><strong>每一次遍历时, 只需要将 <code>currNode</code> 节点的 <code>next</code> 指向 <code>prevNode</code> 节点, 即：</strong></p></blockquote><pre class=" language-java"><code class="language-java">currNode<span class="token punctuation">.</span>next <span class="token operator">=</span> prevNode<span class="token punctuation">;</span></code></pre><blockquote><p><strong>此时新链表前面多了一个节点, 所以需要将 <code>prevNode</code> 即：</strong></p></blockquote><pre class=" language-java"><code class="language-java">prevNode <span class="token operator">=</span> currNode<span class="token punctuation">;</span></code></pre><p><img src="listNode.png" alt=""></p><blockquote></blockquote><p><img src="listNode1.png" alt=""></p><blockquote></blockquote><p><img src="listNode2.png" alt=""></p><blockquote></blockquote><p><img src="listNode3.png" alt=""></p><p><strong>代码实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>alan<span class="token punctuation">.</span>leetcode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 反转链表：例如 输入 1->2->3->4->5->null 输出：5->4->3->2->1->null * leetCode: https://leetcode.com/problems/reverse-linked-list * @author Alan Wang * @date 2018/11/11 21:31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReverseLinkedList</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode listNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> listNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            listNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            listNode <span class="token operator">=</span> listNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------------------开始反转------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode newListNode <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        curr <span class="token operator">=</span> newListNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode nextTemp <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>            prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>            curr <span class="token operator">=</span> nextTemp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. */</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 - Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程实战-第五章：基础构建模块</title>
      <link href="/2018/11/05/JavaConcurrencyInPractice-Chapter05/"/>
      <url>/2018/11/05/JavaConcurrencyInPractice-Chapter05/</url>
      
        <content type="html"><![CDATA[<!-- MarkdownTOC autolink="true" autoanchor="false" --><ul><li><a href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E7%B1%BB">同步容器类</a><ul><li><a href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98">同步容器类的问题</a></li></ul></li><li><a href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8">并发容器</a><ul><li><a href="#concurrenthashmap">ConcurrentHashMap</a></li></ul></li><li><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F">阻塞队列和生产者-消费者模式</a></li><li><a href="#%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E6%B3%95">阻塞方法与中断方法</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB">同步工具类</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E4%B8%94%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98">构建高效且可伸缩的结果缓存</a></li></ul><!-- /MarkdownTOC --><h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>Java 中的<code>同步容器类</code> 包括 <code>Vector</code> 和 <code>Hashtable</code> 以及 <code>Collections.synchronizedXxx</code> 等工厂方法创建的容器，这些同步容器类的实现线程安全的方式是：将类中的每一个共有方法都添加锁，进行同步，每次只能有一个线程访问容器的状态。</p><h4 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h4><blockquote><p>同步容器是线程安全的，但是在某些 <code>复合操作</code> 的情况下会出现一些奇怪的错误，容器的常见 <code>复合操作</code> 包括：<code>迭代</code> <code>跳转(找到当前元素的下一个)</code> <code>条件运算(若不包含则添加)</code><br>现在假如我们有一个 <code>Vector</code> 类型的容器，存放了100个元素，我们有两个线程分别调用两个方法，假如 <code>线程A</code> 调用 <code>getLast</code> 方法，<code>线程B</code> 调用 <code>deleteLast</code> 方法，代码如下：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Vector<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Vector 是同步容器类，虽然是线程安全的，但在某些情况下需要额外的枷锁来保护复合操作 * 例如：线程A调用getList，并且获取到 lastIndex = 10 然后释放了锁; *      线程B获取到锁，调用 deleteLast 同样也获取到 lastIndex = 10; 如果线程B继续获取到锁调用了remove，即将最后一个元素删除 *      然后线程A又重新获取到锁调用 get(10) 则找不到元素，处罚异常 * * @author Alan Wang * @date 2018/11/5 22:25 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VectorTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Vector<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"初始化完成。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        VectorDemo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VectorDemo</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 启动第一个线程</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 启动第二个线程</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">VectorDemo</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Vector<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">VectorDemo</span><span class="token punctuation">(</span>Vector<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Object <span class="token function">getLast</span><span class="token punctuation">(</span>Vector list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// size 方法枷锁了</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastIndex<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程(获取)【"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"】lastIndex = "</span><span class="token operator">+</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span>Vector list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程(删除)【"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"】lastIndex = "</span><span class="token operator">+</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"已删除第："</span><span class="token operator">+</span>lastIndex<span class="token operator">+</span><span class="token string">" 号元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String name <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 第一个线程调用 getLast</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"Thread-0"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">// 第二个线程调用 deleteLast</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"Thread-1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteLast</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>执行的结果</p></blockquote><p><img src="result.png" alt="result"></p><blockquote><p>然后我们来分析一下这个结果，首先线程0 拿到锁，获取到了 lastIndex = 9，然后释放锁，接着线程1 获取到锁，同样获取到 lastIndex = 9，然后锁又被 线程0 拿到了，此使 lastIndex 还是9，然后线程1 又拿到了锁开始删除操作，将下标为 9 的元素删除，释放锁后 线程0 通过上一次拿到的 lastIndex = 9 去获取元素，发现该元素已经不存在了，所以出现数组越界的异常。<br>通过该例子，可以很好的理解为什么 <code>同步容器</code> 在进行一些复合操作的时候会出现错误的结果。</p></blockquote><p>解决该问题的方法是：给客户端枷锁，将 getLast 方法和 deleteLast 方法改为如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getLast</span><span class="token punctuation">(</span>Vector list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// size 方法枷锁了</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastIndex<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程(获取)【"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"】lastIndex = "</span><span class="token operator">+</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span>Vector list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程(删除)【"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"】lastIndex = "</span><span class="token operator">+</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"已删除第："</span><span class="token operator">+</span>lastIndex<span class="token operator">+</span><span class="token string">" 号元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种情况下，getLast 中获取 lastIndex 和 get(lastIndex) 是一个原子操作，当获取到lastIndex后就立即将最后一个元素返回。 同样在 deleteLast 方法中获取 lastIndex 和 delete(lastIndex) 也是一个原则操作，当获取lastIndex后就立即将最后一个元素删除。</p><blockquote><p>可能会出现的一种结果：</p></blockquote><p><img src="result1.png" alt="result"></p><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p><code>同步容器</code> 将所有对容器状态的访问都串行化，以此来实现线程安全，严重降低容器的并发性能，当多个线程竞争容器锁时，吞吐量严重降低。<br><code>并发容器</code> 是针对多线程访问设计的，改进了同步容器的性能问题，极大地提高伸缩性并降低风险。</p><p><code>ConcurrentHashMap</code> 用来代替基于散列的同步Map容器，<code>CopyOnWriteArrayList</code> 用来替代以遍历操作为主的同步List</p><p>Java5 新增两种容器类型 <code>Queue</code> 和 <code>BlockingQueue</code><br><code>Queue</code> 用来临时保存一组等待处理的元素，提供了几种实现：</p><blockquote><p><code>ConcurrentLinkedQueue</code> 传统的先进先出队列<br><code>PriorityQueue</code> (非并发的) 优先队列</p></blockquote><p><code>Queue</code> 上的操作不会阻塞，若队列为空，获取元素的操作将返回控制</p><p><code>BlockingQueue</code> 扩展了 <code>Queue</code>, 增加了可阻塞的插入和获取操作，如果队列为空，那么获取元素的操作将一直阻塞，知道队列中出现一个空用的元素。如果队列已满，那么插入操作将会一直阻塞，在 <code>生产者-消费者</code> 模式中，阻塞队列非常有用。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><code>HashMap</code> 非同步容器，<code>key</code> 和 <code>value</code> 都允许 <code>null</code> 值。<br><code>HashTable</code> 同步容器，<code>key</code> 和 <code>value</code> 不允许 <code>null</code> 值。</p><p>ConcurrentHashMap 也是基于 HashCode 实现的 Map 容器，使用一种粒度更细的机制来提供了更高的并发性和伸缩性，这种机制成为分段锁，在这个机制下，任意数量的读取线程可以并发的访问map，执行读取的线程和执行写入操作的线程也可以同时并发的访问。</p><h2 id="阻塞队列和生产者-消费者模式"><a href="#阻塞队列和生产者-消费者模式" class="headerlink" title="阻塞队列和生产者-消费者模式"></a>阻塞队列和生产者-消费者模式</h2><h2 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h2><h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><h2 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h2>]]></content>
      
      
      <categories>
          
          <category> Java 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技能修炼</title>
      <link href="/2018/11/04/skillsToLearn/"/>
      <url>/2018/11/04/skillsToLearn/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><pre class=" language-java"><code class="language-java">JDK 源码<span class="token operator">:</span> <span class="token string">"String"</span> <span class="token string">"HashMap"</span> <span class="token string">"LinkedHashMap"</span> <span class="token string">"HashTable"</span> <span class="token string">"ConcurrentHashMap"</span> <span class="token string">"ArrayList"</span> <span class="token string">"LinkedList"</span></code></pre><h2 id="中间件-框架"><a href="#中间件-框架" class="headerlink" title="中间件/框架"></a>中间件/框架</h2><pre class=" language-java"><code class="language-java">SpringNettyKafkaDubboZookpper</code></pre><h2 id="SQL-NoSQL"><a href="#SQL-NoSQL" class="headerlink" title="SQL/NoSQL"></a>SQL/NoSQL</h2><pre class=" language-java"><code class="language-java">MySqlRedisMongoDB</code></pre><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><pre class=" language-xml"><code class="language-xml">《Java 核心技术：卷1基础知识》《Spring 实战》《Spring Boot实战》《Effective Java》《Java 并发编程实战》《深入理解 Java 虚拟机》《Java 编程思想》《精通 Spring 4.x》</code></pre><pre class=" language-xml"><code class="language-xml">《代码大全》《设计模式》《重构》《代码简洁之道》《领域区域设计》</code></pre><pre class=" language-xml"><code class="language-xml">《高性能 MySQL》《Redis 实战》《MongoDB 权威指南》</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/03/helloworld/"/>
      <url>/2018/11/03/helloworld/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello，World"><a href="#Hello，World" class="headerlink" title="Hello，World!"></a>Hello，World!</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="世界，你好！"><a href="#世界，你好！" class="headerlink" title="世界，你好！"></a>世界，你好！</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'世界，你好!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
